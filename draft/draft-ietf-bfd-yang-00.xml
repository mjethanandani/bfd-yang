<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="no"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<rfc category="std" docName="draft-ietf-bfd-yang-00.txt" ipr="trust200902">
    <front>
        <title abbrev="BFD Yang">Yang Data Model for Bidirectional Forwarding
    Detection (BFD)</title>
        <author fullname="Lianshu Zheng" initials="L." role="editor" surname="Zheng">
            <organization>Huawei Technologies</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>China</country>
                </postal>
                <email>vero.zheng@huawei.com</email>
            </address>
        </author>
        <author fullname="Reshad Rahman" initials="R." role="editor" surname="Rahman">
            <organization>Cisco Systems</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>Canada</country>
                </postal>
                <email>rrahman@cisco.com</email>
            </address>
        </author>
        <author fullname="Santosh Pallagatti" initials="S." surname="Pallagatti">
            <organization>Juniper Networks</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>India</country>
                </postal>
                <email>santoshpk@juniper.net</email>
            </address>
        </author>
        <author fullname="Mahesh Jethanandani" initials="M." surname="Jethanandani">
            <organization>Cisco Systems</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country/>
                </postal>
                <email>mjethanandani@gmail.com</email>
            </address>
        </author>
        <author fullname="Greg Mirsky" initials="G." surname="Mirsky">
            <organization>Ericsson</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country/>
                </postal>
                <email>gregory.mirsky@ericsson.com</email>
            </address>
        </author>
        <date year="2015"/>
        <abstract>
            <t>This document defines a YANG data model that can be used to configure
      and manage Bidirectional Forwarding Detection (BFD).</t>
        </abstract>
        <note title="Requirements Language">

            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
        </note>
    </front>
    <middle>
        <section title="Introduction">
            <t>YANG <xref
                    target="RFC6020"/> is a data definition language that was
      introduced to define the contents of a conceptual data store that allows
      networked devices to be managed using NETCONF <xref
                    target="RFC6241"/>. 
      YANG is proving relevant beyond its initial confines, as bindings to other 
      interfaces (e.g RESTCONF <xref target="I-D.ietf-netconf-restconf"/>) and encodings other than XML (e.g JSON) are being
      defined. Furthermore, YANG data models can be used as the basis of implementation
      for other interfaces, such as CLI and programmatic APIs.</t>

            <t>This document defines a YANG data model that can be used to configure
      and manage Bidirectional Forwarding Detection (BFD)<xref target="RFC5880"/>. 
      BFD is a network protocol which is used for liveness detection of arbitrary paths between systems. Some examples of different types of paths over which we have BFD:</t>

            <t>1) Two systems directly connected via IP. This is known as BFD over single-hop IP <xref target="RFC5881"/>
            </t>
            <t>2) Two systems connected via multiple hops <xref target="RFC5883"/>
            </t>

            <t>3) Two systems connected via MPLS Label Switched Paths (LSPs) <xref target="RFC5884"/>
            </t>

            <t>4) Two systems connected via a Link Aggregation Group (LAG) interface <xref target="RFC7130"/>
            </t>

            <t>BFD typically does not operate on its own. Various control protocols, also known as BFD clients, use the services provided by BFD for their own operation <xref target="RFC5882"/>. The obvious candidates which use BFD are those which do not have Hellos to detect failures, e.g. static routes, and routing protocols whose Hellos do not suport sub-second failure detection, e.g. OSPF and IS-IS.
		</t>
            <section title="Contributors">
                <t/>
            </section>
        </section>
        <section title="Design of the Data Model">
           <t>The BFD YANG data model follows a VRF-centric model by augmenting the "routing-protocol" data node in <xref target="I-D.ietf-netmod-routing-cfg"/>. </t>
            <t/>
            <section title="Design of Configuration Model">
                <t/>

                <t>The configuration model consists mainly of the parameters specified in <xref target="RFC5880"/>. Some examples are desired minimum transmit interval, required minimum receive interval, detection multiplier, etc </t>
                <t>Some implementations have BFD session configuration under the BFD clients. For example, BFD session configuration is under routing applications such as OSPF, IS-IS, BGP etc. Other implementations have BFD session configuration centralized under BFD, i.e. outside the multiple BFD clients.</t>
                <t>The BFD parameters of interest to a BFD client are mainly the multiplier and interval(s) since those parameters impact the convergence time of the BFD clients when a failure occurs. So the configuration model has groupings, containing multiplier and interval(s), which are to be used by BFD clients. Other parameters which remain under BFD control, e.g. demand mode and authentication, are configured under BFD.</t>
                <t>We provide groupings, which contain the basic BFD session parameters, for applications to use. This ensures consistency of BFD parameters across applications.</t>
                <t>Although <xref target="RFC5880"/> allows for different values for transmit and receive intervals, many implementations allow users to specify just one interval which is used for both transmit and receive intervals or separate values for transmit and receive intervals. Our YANG model supports this: there is a choice between "min-interval", used for both transmit and receive intervals, and "desired-min-tx-interval" and "required-min-rx-interval".</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
                
                <section  anchor="IP-SH-CFG"  title="Single-hop IP">
                   <t>For single-hop IP, the BFD multiplier and interval(s) are configured in BFD clients. It is highly desirable to have the BFD configuration consistent between those clients. Therefore, we have a grouping for BFD configuration that applications can import in their YANG module:</t>
                    <t>- This provides consistency since the same grouping is being used in all applications making use of BFD.</t>
                    <t>- Not all implementations of those BFD clients have support for BFD, we must use if-feature in the respective YANG modules.</t>
                    <t>An application importing the BFD configuration grouping could do so in a hierarchical manner if it has multiple levels at which BFD configuration can be applied. In a subsequent section, we provide an example of how a BFD client would use the grouping in such a way.</t>
                    <t> The configuration items are:
          <list
                            hangIndent="8" style="hanging">
                            <t hangText="enabled">
                                <vspace/>Set to true to enable BFD.</t>
                            <t hangText="local-multiplier">

                                <vspace/>This is the detection time multiplier as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="min-interval">

                                <vspace/>This is the Desired Min TX Interval and Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                                <t>OR</t>
                            <t hangText="desired-min-tx-interval">

                                <vspace/>This is the Desired Min TX Interval as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="required-min-rx-interval">

                                <vspace/>This is the Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                        </list>
                    </t>
                </section>

                <section title="Multi-hop IP">

                    <t>We have a list for BFD sessions over multi-hop IP. The key consists of:
          <list
                            hangIndent="8" style="hanging">
                            <t hangText="source address">

                                <vspace/>Address belonging to the local system as per <xref target="RFC5883"/>
                            </t>
                            <t hangText="destination address">

                                <vspace/>Address belonging to the remote system as per <xref target="RFC5883"/>
                            </t>
                        </list>
                    </t>
                    <t>Since we are following a VRF-centric model we do not need a VRF field in the key.</t>
                    <t>Here is the list of parameters:
          <list
                            hangIndent="8" style="hanging">
                            <t hangText="local-multiplier">

                                <vspace/>This is the detection time multiplier as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="desired-min-tx-interval">

                                <vspace/>This is the Desired Min TX Interval as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="required-min-rx-interval">

                                <vspace/>This is the Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="demand-enabled">

                                <vspace/>Set to true to enable demand mode as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="enable-authentication">
                                <vspace/>Set to true to enable BFD authentication.</t>
                            <t hangText="authentication-algorithm">
                                <vspace/>Authentication algorithm to use, if enabled.</t>
                            <t hangText="key-chain-name">
                                <vspace/>Key-chain to be used for authentication, if enabled.</t>                            
                            <t hangText="tx-ttl">
                                <vspace/>TTL of outgoing BFD control packets.</t>
                            <t hangText="rx-ttl">
                                <vspace/>Minimum TTL of incoming BFD control packets.</t>
                        </list>
                    </t>
                </section>
                
                <section title="Traffic Engineering Tunnels">
                   <t>For Traffic Engineering (TE) tunnels, BFD is configured under the TE tunnel since it is the Traffic Enginnering application which knows the desired failure detection parameters. The grouping for BFD clients in <xref target="IP-SH-CFG"/> can be used by the TE application for the basic BFD parameters. For BFD parameters which are specific to the TE application, e.g. whether to tear down the tunnel in the event of a BFD session failure, these parameters will be defined in the YANG model of the TE application.</t>
                </section>
                <section title="LDP Label Switched Paths">
                   <t>For LDP LSPs, BFD is configured under the LDP FEC. The grouping for BFD clients in <xref target="IP-SH-CFG"/> can be used by the LDP application for the basic BFD parameters. For BFD parameters which are specific to the LDP application, if any, these parameters will be defined in the YANG model of the LDP application.</t>
                </section>       
                <section title="Link Aggregation Groups">
                   <t>Per <xref target="RFC7130"/>, configuring BFD on LAG consists of having micro-BFD sessions on each LAG member link. The grouping for BFD clients in <xref target="IP-SH-CFG"/> can be used by the LAG application for the basic BFD parameters. This grouping can be used per-LAG or per member-link. For BFD parameters which are specific to the LAG application, e.g. the IP address of the peer system which can be reached by the LAG, the parameters will be defined in the YANG model of the LAG application. </t>
                </section>         
                
                <section anchor="INTF-CFG" title="Per-interface Configuration">

                    <t>With multiplier and intervals configured under the BFD clients, we still need a central location to configure authentication, demand mode, etc. This can be done by configuring the following parameters per interface:
      <list
                            hangIndent="8" style="hanging">
                            <t hangText="demand-enabled">

                                <vspace/>Set to true to enable demand mode as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="enable-authentication">
                                <vspace/>Set to true to enable BFD authentication.</t>
                            <t hangText="authentication-algorithm">
                                <vspace/>Authentication algorithm to use, if enabled.</t>
                            <t hangText="key-chain-name">
                                <vspace/>Key-chain to be used for authentication, if enabled.</t>

                            <t hangText="desired-min-echo-tx-interval">

                                <vspace/>This is the minimum interval that the local system would like to use when transmitting BFD echo packets. If 0, the echo function as defined in <xref target="RFC5880"/> is disabled.
                            </t>
                            <t hangText="required-min-echo-rx-interval">

                                <vspace/>This is the Required Min Echo RX Interval as defined in <xref target="RFC5880"/>.
                            </t>
                        </list>
                    </t>
                </section>
                
            </section>
            <section title="Design of Operational Model">
                <t>The operational model contains both the overall statistics of BFD sessions running on the device and the per session operational statistics. Since BFD is used for liveness detection of arbitrary paths, there is no uniform key to identify a BFD session. E.g. a BFD single-hop IP session is uniquely identified by the combination of destination IP address and interface whereas a multihop IP session is uniquely identified by the combination of source IP address and destination IP address (in the context of a VRF).  For this reason, for per-session operational statistics, we do not have a single list with different type BFD sessions.  Instead, we have a container where we have multiple lists, where each list corresponds to one specific path type for BFD.  For example, we have one operational list for BFD single-hop IP, another list for BFD multi-hop IP, etc.  In each list, mainly three categories of operational items are shown.  The fundamental information of a BFD session such as the local discriminator, remote discriminator and the capability of supporting demand detect mode are shown in the first category.  The second category includes a BFD session running information, e.g. the FSM the device in and diagnostic code received.  Another example is the actual transmit interval between the control packets, which may be different from the desired minimum transmit interval configured, is shown in this category.  Similar examples are actual received interval between the control packets and the actual transmit interval between the echo packets.  The third category contains the detailed statistics of the session, e.g. when the session transitioned up/down and how long it has been in that state.</t>
                <t>For some session types, there may be more than 1 session on the virtual path to the destination. For example, with IP multi-hop there could be multiple BFD sessions from the source to the same destination to test the various paths (ECMP) to the destination. Each of the BFD sessions on the same virtual path is uniquely identified by the source UDP port</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
            </section>
            <section title="Notifications">
                <t>This YANG model defines a list of notifications to inform clients of BFD of important events detected during the protocol operation. Pair of local and remote discriminator identifies a BFD session on local system. Notifications also give more important details about BFD sessions; e.g. new state, time in previous state, routing-instance and the reason that the BFD session state changed.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
            </section>
            <section title="RPC Operations">
                <t>TBD</t>
            </section>
            <section title="BFD Configuration Data Hierarchy">
                <section title="Centralized BFD Configuration">
                    <t>The following is the centralized configuration data hierarchy: </t>
                    <t>We have a container which contains a list for each session type. This contains session configuration for only IP multi-hop sessions.</t>
                    <t>We have per-interface configuration for authentication, demand-mode, etc. This is used e.g. for IP single-hop sessions whose base BFD configuration belongs to the BFD clients.</t>
                    <figure align="left">
                        <preamble/>
                        <artwork align="left">
module: ietf-bfd
augment /rt:routing/rt:routing-instance/rt:routing-protocols/
         rt:routing-protocol:
   +--rw bfd
      +--rw bfd-cfg
      |  +--rw bfd-session-cfg
      |  |  +--rw session-ip-mh* [source-addr dest-addr]
      |  |     +--rw source-addr                 inet:ip-address
      |  |     +--rw dest-addr                   inet:ip-address
      |  |     +--rw admin-down?                 boolean
      |  |     +--rw local-multiplier?           multiplier
      |  |     +--rw (interval-config-type)?
      |  |     |  +--:(tx-rx-intervals)
      |  |     |  |  +--rw desired-min-tx-interval     uint32
      |  |     |  |  +--rw required-min-rx-interval    uint32
      |  |     |  +--:(single-interval)
      |  |     |     +--rw min-interval                uint32
      |  |     +--rw demand-enabled?             boolean
      |  |     +--rw enable-authentication?      boolean
      |  |     +--rw authentication-parms {bfd-authentication}?
      |  |     |  +--rw key-chain-name?   string
      |  |     |  +--rw algorithm?        bfd-auth-algorithm
      |  |     +--rw tx-ttl?                     ttl
      |  |     +--rw rx-ttl                      ttl
      |  +--rw bfd-interface-cfg* [interface] {bfd-interface-config}?
      |     +--rw interface                        if:interface-ref
      |     +--rw local-multiplier?                multiplier
      |     +--rw (interval-config-type)?
      |     |  +--:(tx-rx-intervals)
      |     |  |  +--rw desired-min-tx-interval          uint32
      |     |  |  +--rw required-min-rx-interval         uint32
      |     |  +--:(single-interval)
      |     |     +--rw min-interval                     uint32
      |     +--rw demand-enabled?                  boolean
      |     +--rw enable-authentication?           boolean
      |     +--rw authentication-parms {bfd-authentication}?
      |     |  +--rw key-chain-name?   string
      |     |  +--rw algorithm?        bfd-auth-algorithm
      |     +--rw desired-min-echo-tx-interval?    uint32
      |     +--rw required-min-echo-rx-interval?   uint32
          </artwork>
                    </figure>
                </section>
                <section title="Configuration in BFD clients">
                    <t>The following is the configuration data hierarchy for a hypothetical BFD client called example-bfd-routing-app. The BFD configuration is supported conditionally via use of if-feature. </t>
                    <t>We have a list of areas and in each area we have a list of interfaces. The BFD configuration grouping is used in a hierarchical fashion, it can be applied in "area" and "interface": </t>
                    <t>- If BFD configuration is applied under an interface, that configuration takes precedence over any BFD configuration, if any, at the area level</t>
                    <t>- If BFD configuration is applied under an "area" and none of the interfaces in that area has BFD configuration, then all interfaces belong to the "area" in question inherit the BFD configuration for the area in question.</t>
                    <t>- If the BFD client implementation supports "interface all", then all the interfaces belonging to that area will inherit the BFD configuration under "interface all". Additionally, if there is specific interface configuration, then the specific interface will override the "interface all" parameters.</t>
                    <t>- The tx and rx intervals can be configured separately or a single interval can be configured.</t>
                    <figure align="left">
                        <preamble/>
                        <artwork align="left">
module: example-bfd-routing-app
   +--rw area* [area-id]
      +--rw area-id      uint32
      +--rw bfd-cfg
      |  +--rw enabled?                    boolean
      |  +--rw local-multiplier?           multiplier
      |  +--rw (interval-config-type)?
      |     +--:(tx-rx-intervals)
      |     |  +--rw desired-min-tx-interval     uint32
      |     |  +--rw required-min-rx-interval    uint32
      |     +--:(single-interval)
      |        +--rw min-interval                uint32
      +--rw interface* [interface]
         +--rw interface    if:interface-ref
         +--rw bfd-cfg
            +--rw enabled?                    boolean
            +--rw local-multiplier?           multiplier
            +--rw (interval-config-type)?
               +--:(tx-rx-intervals)
               |  +--rw desired-min-tx-interval     uint32
               |  +--rw required-min-rx-interval    uint32
               +--:(single-interval)
                  +--rw min-interval                uint32

          </artwork>
                    </figure>
                </section>
            </section>
            <section title="Operational Data Hierarchy">
                <t>The complete data hierarchy of BFD YANG operational model is presented below.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
                       
module: ietf-bfd
augment /rt:routing/rt:routing-instance/rt:routing-protocols/
         rt:routing-protocol:
   +--rw bfd
      +--ro bfd-oper
         +--ro bfd-session-statistics
         |  +--ro ip-sh-session-num?     uint32
         |  +--ro ip-mh-session-num?     uint32
         |  +--ro total-session-num?     uint32
         |  +--ro session-up-num?        uint32
         |  +--ro sess-down-num?         uint32
         |  +--ro sess-admin-down-num?   uint32
         +--ro bfd-session-lists
            +--ro session-ip-sh* [interface dest-addr]
            |  +--ro interface               if:interface-ref
            |  +--ro dest-addr               inet:ip-address
            |  +--ro source-addr?            inet:ip-address
            |  +--ro session-type?           bfd-session-type
            |  +--ro local-discriminator?    discriminator
            |  +--ro remote-discriminator?   discriminator
            |  +--ro remote-multiplier?      multiplier
            |  +--ro out-interface?          if:interface-ref
            |  +--ro demand-capability?      boolean
            |  +--ro source-port?            inet:port-number
            |  +--ro dest-port?              inet:port-number
            |  +--ro session-running*
            |  |  +--ro session-index?                 uint32
            |  |  +--ro local-state?                   state
            |  |  +--ro remote-state?                  state
            |  |  +--ro local-diagnostic?              diagnostic
            |  |  +--ro remote-diagnostic?             diagnostic
            |  |  +--ro detection-mode?                enumeration
            |  |  +--ro negotiated-tx-interval?        uint32
            |  |  +--ro negotiated-rx-interval?        uint32
            |  |  +--ro negotiated-echo-tx-interval?   uint32
            |  |  +--ro detection-time?                uint32
            |  +--ro sesssion-statistics*
            |     +--ro create-time?            yang:date-and-time
            |     +--ro last-down-time?         yang:date-and-time
            |     +--ro last-up-time?           yang:date-and-time
            |     +--ro down-count?             uint32
            |     +--ro admin-down-count?       uint32
            |     +--ro receive-packet-count?   uint64
            |     +--ro send-packet-count?      uint64
            |     +--ro receive-bad-packet?     uint64
            |     +--ro send-failed-packet?     uint64
            +--ro session-ip-mh-group* [source-addr dest-addr]
            |  +--ro source-addr      inet:ip-address
            |  +--ro dest-addr        inet:ip-address
            |  +--ro session-ip-mh* [source-port]
            |     +--ro ttl?                    ttl
            |     +--ro session-type?           bfd-session-type
            |     +--ro local-discriminator?    discriminator
            |     +--ro remote-discriminator?   discriminator
            |     +--ro remote-multiplier?      multiplier
            |     +--ro out-interface?          if:interface-ref
            |     +--ro demand-capability?      boolean
            |     +--ro source-port             inet:port-number
            |     +--ro dest-port?              inet:port-number
            |     +--ro session-running*
            |     |  +--ro session-index?                 uint32
            |     |  +--ro local-state?                   state
            |     |  +--ro remote-state?                  state
            |     |  +--ro local-diagnostic?              diagnostic
            |     |  +--ro remote-diagnostic?             diagnostic
            |     |  +--ro detection-mode?                enumeration
            |     |  +--ro negotiated-tx-interval?        uint32
            |     |  +--ro negotiated-rx-interval?        uint32
            |     |  +--ro negotiated-echo-tx-interval?   uint32
            |     |  +--ro detection-time?                uint32
            |     +--ro sesssion-statistics*
            |        +--ro create-time?            yang:date-and-time
            |        +--ro last-down-time?         yang:date-and-time
            |        +--ro last-up-time?           yang:date-and-time
            |        +--ro down-count?             uint32
            |        +--ro admin-down-count?       uint32
            |        +--ro receive-packet-count?   uint64
            |        +--ro send-packet-count?      uint64
            |        +--ro receive-bad-packet?     uint64
            |        +--ro send-failed-packet?     uint64
            +--ro session-te-tunnel* [tunnel-name]
            |  +--ro tunnel-name             string
            |  +--ro session-type?           bfd-session-type
            |  +--ro local-discriminator?    discriminator
            |  +--ro remote-discriminator?   discriminator
            |  +--ro remote-multiplier?      multiplier
            |  +--ro out-interface?          if:interface-ref
            |  +--ro demand-capability?      boolean
            |  +--ro source-port?            inet:port-number
            |  +--ro dest-port?              inet:port-number
            |  +--ro session-running*
            |  |  +--ro session-index?                 uint32
            |  |  +--ro local-state?                   state
            |  |  +--ro remote-state?                  state
            |  |  +--ro local-diagnostic?              diagnostic
            |  |  +--ro remote-diagnostic?             diagnostic
            |  |  +--ro detection-mode?                enumeration
            |  |  +--ro negotiated-tx-interval?        uint32
            |  |  +--ro negotiated-rx-interval?        uint32
            |  |  +--ro negotiated-echo-tx-interval?   uint32
            |  |  +--ro detection-time?                uint32
            |  +--ro sesssion-statistics*
            |     +--ro create-time?            yang:date-and-time
            |     +--ro last-down-time?         yang:date-and-time
            |     +--ro last-up-time?           yang:date-and-time
            |     +--ro down-count?             uint32
            |     +--ro admin-down-count?       uint32
            |     +--ro receive-packet-count?   uint64
            |     +--ro send-packet-count?      uint64
            |     +--ro receive-bad-packet?     uint64
            |     +--ro send-failed-packet?     uint64
            +--ro session-ldp-lsp-group* [ldp-fec]
            |  +--ro ldp-fec            inet:ip-prefix
            |  +--ro session-ldp-lsp* [source-port]
            |     +--ro ttl?                    ttl
            |     +--ro session-type?           bfd-session-type
            |     +--ro local-discriminator?    discriminator
            |     +--ro remote-discriminator?   discriminator
            |     +--ro remote-multiplier?      multiplier
            |     +--ro out-interface?          if:interface-ref
            |     +--ro demand-capability?      boolean
            |     +--ro source-port             inet:port-number
            |     +--ro dest-port?              inet:port-number
            |     +--ro session-running*
            |     |  +--ro session-index?                 uint32
            |     |  +--ro local-state?                   state
            |     |  +--ro remote-state?                  state
            |     |  +--ro local-diagnostic?              diagnostic
            |     |  +--ro remote-diagnostic?             diagnostic
            |     |  +--ro detection-mode?                enumeration
            |     |  +--ro negotiated-tx-interval?        uint32
            |     |  +--ro negotiated-rx-interval?        uint32
            |     |  +--ro negotiated-echo-tx-interval?   uint32
            |     |  +--ro detection-time?                uint32
            |     +--ro sesssion-statistics*
            |        +--ro create-time?            yang:date-and-time
            |        +--ro last-down-time?         yang:date-and-time
            |        +--ro last-up-time?           yang:date-and-time
            |        +--ro down-count?             uint32
            |        +--ro admin-down-count?       uint32
            |        +--ro receive-packet-count?   uint64
            |        +--ro send-packet-count?      uint64
            |        +--ro receive-bad-packet?     uint64
            |        +--ro send-failed-packet?     uint64
            +--ro session-lag* [lag-name]
               +--ro lag-name             if:interface-ref
               +--ro session-lag-micro* [member-link]
                  +--ro member-link             if:interface-ref
                  +--ro session-type?           bfd-session-type
                  +--ro local-discriminator?    discriminator
                  +--ro remote-discriminator?   discriminator
                  +--ro remote-multiplier?      multiplier
                  +--ro out-interface?          if:interface-ref
                  +--ro demand-capability?      boolean
                  +--ro source-port?            inet:port-number
                  +--ro dest-port?              inet:port-number
                  +--ro session-running*
                  |  +--ro session-index?                 uint32
                  |  +--ro local-state?                   state
                  |  +--ro remote-state?                  state
                  |  +--ro local-diagnostic?              diagnostic
                  |  +--ro remote-diagnostic?             diagnostic
                  |  +--ro detection-mode?                enumeration
                  |  +--ro negotiated-tx-interval?        uint32
                  |  +--ro negotiated-rx-interval?        uint32
                  |  +--ro negotiated-echo-tx-interval?   uint32
                  |  +--ro detection-time?                uint32
                  +--ro sesssion-statistics*
                     +--ro create-time?            yang:date-and-time
                     +--ro last-down-time?         yang:date-and-time
                     +--ro last-up-time?           yang:date-and-time
                     +--ro down-count?             uint32
                     +--ro admin-down-count?       uint32
                     +--ro receive-packet-count?   uint64
                     +--ro send-packet-count?      uint64
                     +--ro receive-bad-packet?     uint64
                     +--ro send-failed-packet?     uint64
                       
        </artwork>
                </figure>
            </section>
            <section title="Notifications">
                <t>The BFD YANG data model defines notifications for BFD session state changes.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
module: ietf-bfd
augment /rt:routing/rt:routing-instance/rt:routing-protocols/
         rt:routing-protocol:
notifications:
   +---n bfd-singlehop-notification    
   |  +--ro local-discr?              discriminator
   |  +--ro remote-discr?             discriminator
   |  +--ro new-state?                state
   |  +--ro state-change-reason?      string
   |  +--ro time-in-previous-state?   string
   |  +--ro dest-addr?                inet:ip-address
   |  +--ro source-addr?              inet:ip-address
   |  +--ro session-index?            uint32
   |  +--ro session-type?             bfd-session-type
   |  +--ro interface?                if:interface-ref
   |  +--ro echo-enabled?             boolean
   +---n bfd-multihop-notification     
   |  +--ro local-discr?              discriminator
   |  +--ro remote-discr?             discriminator
   |  +--ro new-state?                state
   |  +--ro state-change-reason?      string
   |  +--ro time-in-previous-state?   string
   |  +--ro dest-addr?                inet:ip-address
   |  +--ro source-addr?              inet:ip-address
   |  +--ro session-index?            uint32
   |  +--ro session-type?             bfd-session-type
   +---n bfd-te-tunnel-notification    
   |  +--ro local-discr?              discriminator
   |  +--ro remote-discr?             discriminator
   |  +--ro new-state?                state
   |  +--ro state-change-reason?      string
   |  +--ro time-in-previous-state?   string
   |  +--ro dest-addr?                inet:ip-address
   |  +--ro source-addr?              inet:ip-address
   |  +--ro session-index?            uint32
   |  +--ro session-type?             bfd-session-type
   |  +--ro tunnel-name?              string
   +---n bfd-ldp-lsp-notification      
   |  +--ro local-discr?              discriminator
   |  +--ro remote-discr?             discriminator
   |  +--ro new-state?                state
   |  +--ro state-change-reason?      string
   |  +--ro time-in-previous-state?   string
   |  +--ro dest-addr?                inet:ip-address
   |  +--ro source-addr?              inet:ip-address
   |  +--ro session-index?            uint32
   |  +--ro session-type?             bfd-session-type
   |  +--ro ldp-fec?                  inet:ip-prefix
   |  +--ro source-port?              inet:port-number
   +---n bfd-lag-notification          
      +--ro local-discr?              discriminator
      +--ro remote-discr?             discriminator
      +--ro new-state?                state
      +--ro state-change-reason?      string
      +--ro time-in-previous-state?   string
      +--ro dest-addr?                inet:ip-address
      +--ro source-addr?              inet:ip-address

        </artwork>
                </figure>
            </section>
            <section title="Examples">
                <t/>
            </section>
            <section title="Interaction with other YANG modules">
                <t>TBD.</t>
            </section>
            <section title="BFD Yang Module">
                <figure align="left">
                    <preamble/>
                    <artwork align="left"><![CDATA[
<CODE BEGINS> file "ietf-bfd@2015-07-01.yang"
module ietf-bfd {
  namespace "urn:ietf:params:xml:ns:yang:ietf-bfd";
  // replace with IANA namespace when assigned
  prefix "bfd";
   
  import ietf-interfaces {
    prefix "if";
  }
  import ietf-inet-types {
    prefix "inet";
  }
  import ietf-yang-types {
    prefix "yang";
  }
  import ietf-routing {
    prefix "rt";
  }
  organization "IETF BFD Working Group";
  contact 
    "WG Web:   <http://tools.ietf.org/wg/bfd>
     WG List:  <rtg-bfd@ietf.org>
     WG Chair: Jeff Haas
     WG Chair: Nobo Akiya
     Editor:   Lianshu Zheng and Reshad Rahman";
  description 
    "This module contains the YANG definition for BFD parameters as
     per RFC5880, RFC5881 and RFC5883";
  revision 2015-07-01 {
    description "Initial revision.";
    reference "RFC XXXX: A YANG data model for BFD";
  }
  identity bfd {
    base "rt:routing-protocol";
    description "BFD protocol";
  }
  typedef discriminator {
    type uint32 {
      range 1..4294967295;
    }
    description "BFD discriminator";
  }
  typedef diagnostic {    
    type enumeration {
      enum none {
        value 0;
        description "None";
      }
      enum controlExpiry {
        value 1;
        description "Control timer expiry";
      }
      enum echoFailed {
        value 2;
        description "Echo failure";
      }
      enum nborDown {
        value 3;
        description "Neighbor down";
      }
      enum fwdingReset {
        value 4;
        description "Forwarding reset";
      }
      enum pathDown {
        value 5;
        description "Path down";
      }
      enum concPathDown {
        value 6;
        description "Concatenated path down";
      }
      enum adminDown {
        value 7;
        description "Admin down";
      }
      enum reverseConcPathDown {
        value 8;
        description "Reverse concatenated path down";
      }
    }
    description "BFD diagnostic";
  }
  typedef state {    
    type enumeration {
      enum adminDown {
        value 0;
        description "admindown";
      }
      enum down {
        value 1;
        description "down";
      }
      enum init {
        value 2;
        description "init";
      }
      enum up {
        value 3;
        description "up";
      }
    }
    description "BFD state";
  }
  typedef multiplier {
    type uint8 {
      range 1..255;
    }
    description "Multiplier";
  }
  typedef ttl {
    type uint8 {
      range 1..255;
    }
    description "Time To Live";
  }
  typedef bfd-session-type {
    type enumeration {
      enum ip-single-hop {
        description "IP single hop";
      }
      enum ip-multi-hop {
        description "IP multi hop";
      }
      enum te-tunnel {
        description "Traffic Engineering tunnes";
      }
      enum ldp-lsp {
        description "LDP Label Switched Path";
      }
      enum lag {
        description "Micro-BFD on LAG member links";
      }
    }
    description 
      "BFD session type, this indicates the path type that BFD is
       running on";
  }
  typedef bfd-auth-algorithm {
    type enumeration {
      enum simple-password {
        description
          "Simple password";
      }
      
      enum keyed-md5 {
        description
          "Keyed message Digest 5";
      }
      
      enum meticulous-keyed-md5 {
        description
          "Meticulous keyed message Digest 5";
      }
                                               
      enum keyed-sha-1 {
        description
          "Keyed secure hash algorithm (SHA1) ";
      }
                                               
      enum meticulous-keyed-sha-1 {
        description
          "Meticulous keyed secure hash algorithm (SHA1) ";
      }
    }
    description "Authentication algorithm";
  }
  feature bfd-interface-config {
    description "BFD per-interface config supported";
  }
  feature bfd-authentication {
    description "BFD authentication supported";
  }
  grouping bfd-grouping-base-cfg-parms {
    description "BFD grouping for base config parameters";
    leaf local-multiplier {
      type multiplier;
      default 3;
      description "Multiplier transmitted by local system";
    }
    choice interval-config-type {
      description 
        "Two interval values or 1 value used for both tx and rx";
      case tx-rx-intervals {
        leaf desired-min-tx-interval {
          type uint32;
          units microseconds;
          mandatory true;
          description 
            "Desired minimum transmit interval of control packets";
        }
        leaf required-min-rx-interval {
          type uint32;
          units microseconds;
          mandatory true;
          description 
            "Required minimum receive interval of control packets";
        }
      }
      case single-interval {
        leaf min-interval {
          type uint32;
          units microseconds;
          mandatory true;
          description 
            "Desired minimum transmit interval and required " +
            "minimum receive interval of control packets";
        }
      }
    }
  }
  grouping bfd-grouping-common-cfg-parms {
    description "BFD grouping for common config parameters";
    
    uses bfd-grouping-base-cfg-parms;
    leaf demand-enabled {
      type boolean;
      default false;
      description "To enbale demand mode";
    }
    leaf enable-authentication {
      type boolean;
      default false;
      description 
        "If set, the Authentication Section is present and the 
         session is to be authenticated (see RFC5880 section 6.7 
         for details).";
    }
    container authentication-parms {
      if-feature bfd-authentication;
      description "Parameters for authentication";
      leaf key-chain-name {
        type string;
        must "../algorithm" {
          error-message
            "May not be configured without algorithm";
          description "Requires algorithm";
        }
        description
          "Key chain name";
      }
      leaf algorithm {
        type bfd-auth-algorithm;
        must "../key-chain" {
          error-message
            "May not be configured without key-chain";
          description "Requires key-chain";
        }
        description "Authentication algorithm to be used";
      }
    }
  }
  grouping bfd-grouping-echo-cfg-parms {
    description "BFD grouping for echo config parameters";
    leaf desired-min-echo-tx-interval {
      type uint32;
      units microseconds;
      default 0;
      description "Desired minumum transmit interval for echo";
    }
    leaf required-min-echo-rx-interval {
      type uint32;
      units microseconds;
      default 0;
      description "Required minimum receive interval for echo";
    }
  }
  grouping bfd-client-base-cfg-parms {
    description 
      "BFD grouping for base config parameters which could be used 
       by a protocol which is a client of BFD";
    
    container bfd-cfg {
      description "BFD configuration";
      leaf enabled {
        type boolean;
        default false;
        description "True if BFD is enabled";
      }
      uses bfd-grouping-base-cfg-parms;
    }
  }
  grouping bfd-all-session {
    description "BFD session operational information";
    leaf session-type {
      type bfd-session-type;
      description 
        "BFD session type, this indicates the path type that BFD is 
        running on";
    }
    leaf local-discriminator {
      type discriminator;
      description "Local discriminator";
    }
    leaf remote-discriminator {
      type discriminator;
      description "Remote discriminator";
    }
    leaf remote-multiplier {
      type multiplier;
      description "Remote multiplier";
    }
    leaf out-interface {
      type if:interface-ref;
      description "Outgoing physical interface name";
    }                
    leaf demand-capability {
      type boolean;
      description "Local demand mode capability";
    }    
    leaf source-port {
      type inet:port-number;
      description "Source UDP port";
    }
    leaf dest-port {
      type inet:port-number;
      description "Destination UDP port";
    }
    list session-running {
      description "BFD session running information";
      leaf session-index {
        type uint32;
        description 
          "An index used to uniquely identify BFD sessions";
      }
      leaf local-state {
        type state;
        description "Local state";
      }
      leaf remote-state {
        type state;
        description "Remote state";
      } 
      leaf local-diagnostic {
        type diagnostic;
        description "Local diagnostic";
      }
      leaf remote-diagnostic {
        type diagnostic;
        description "Remote diagnostic";
      }
      leaf detection-mode {
        type enumeration {
          enum async-with-echo {
            value "1";
            description "Async with echo";
          }
          enum async-without-echo {
            value "2";
            description "Async without echo";
          }
          enum demand-with-echo {
            value "3";
            description "Demand with echo";
          }
          enum demand-without-echo {
            value "4";
            description "Demand without echo";
          }
        }
        description "Detection mode";
      }
      leaf negotiated-tx-interval {
        type uint32;
        units microseconds;
        description "Negotiated transmit interval";
      }
      leaf negotiated-rx-interval {
        type uint32;
        units microseconds;
        description "Negotiated receive interval";
      }
      leaf negotiated-echo-tx-interval {
        type uint32;
        units microseconds;
        description "Negotiated echo transmit interval";
      }
      leaf detection-time {
        type uint32;
        units microseconds;
        description "Detection time";
      }
    }
    list sesssion-statistics {
      description "BFD session statistics";
      leaf create-time {
        type yang:date-and-time;
        description 
          "Time and date when session was created";
      }
      leaf last-down-time {
        type yang:date-and-time;
        description 
          "Time and date of last time the session went down";
      }
      leaf last-up-time {
        type yang:date-and-time;
        description 
          "Time and date of last time the session went up";
      }
      leaf down-count {
        type uint32;
        description "Session Down Count";
      }
      leaf admin-down-count {
        type uint32;
        description "Session Admin-Down Count";
      }
      leaf receive-packet-count {
        type uint64;
        description "Received Packet Count";
      }
      leaf send-packet-count {
        type uint64;
        description "Sent Packet Count";
      }
      leaf receive-bad-packet {
        type uint64;
        description "Received bad packet count";
      }
      leaf send-failed-packet {
        type uint64;
        description "Packet Failed to Send Count";
      }
    }
  }
  augment "/rt:routing/rt:routing-instance/rt:routing-protocols/"
    + "rt:routing-protocol" {
    when "rt:type = 'bfd:bfd'" {
      description
        "This augment is only valid for a protocol instance
        of BFD.";
    }
    description "BFD augmentation.";
    container bfd {
      description "BFD top-level container";
      container bfd-cfg {
        description "BFD configuration";
        container bfd-session-cfg {
          description "BFD session configuration";
          list session-ip-mh {
            key "source-addr dest-addr";
            description "List of IP multi-hop sessions";
            leaf source-addr {
              type inet:ip-address;
              description 
                "Local IP address";
            }
            leaf dest-addr {
              type inet:ip-address;
              description
                "IP address of the peer";
            }
            leaf admin-down {
              type boolean;
              default false;
              description 
                "Is the BFD session administratively down";
            }
            uses bfd-grouping-common-cfg-parms;
            leaf tx-ttl {
              type ttl;
              default 255;
              description "TTL of outgoing BFD control packets";
            }
            leaf rx-ttl {
              type ttl;
              mandatory true;
              description 
                "Minimum allowed TTL value for incoming BFD control 
                 packets";
            }
          }
        }
        list bfd-interface-cfg {
          if-feature bfd-interface-config;
          key interface;
          description "Per-interface BFD configuration";
          leaf interface {
            type if:interface-ref;
            description "Interface";
          }
          uses bfd-grouping-common-cfg-parms;
          uses bfd-grouping-echo-cfg-parms;   
        }
      }
      container bfd-oper {
        config "false";      
        description "BFD operational container";
        container bfd-session-statistics {      
          description "BFD session counters";
          leaf ip-sh-session-num {
            type uint32;
            description "IP single hop session number";
          }
          leaf ip-mh-session-num {
            type uint32;
            description "IP multi hop session Number";
          }
          leaf total-session-num {
            type uint32;
            description "Total session number";
          }
          leaf session-up-num {
            type uint32;
            description "Session up number";
          }
          leaf sess-down-num {
            type uint32;
            description "Session down number";
          }
          leaf sess-admin-down-num {
            type uint32;
            description "Session admin-down number";
          }
        }
    
        container bfd-session-lists {
          description 
            "Contains multiple session lists, one per type";
          list session-ip-sh {
            key "interface dest-addr";
            description "BFD IP single-hop sessions";
            leaf interface {
              type if:interface-ref;
              description 
                "Interface on which the BFD session is running.";
            }
            leaf dest-addr {
              type inet:ip-address;
              description "BFD peer address";
            }
            leaf source-addr {
              type inet:ip-address;
              description "BFD source address";
            }
            uses bfd-all-session;
          }
          list session-ip-mh-group {
            key "source-addr dest-addr";
            description 
              "BFD IP multi-hop group of sessions. A group of " +
              "sessions is between 1 source and 1 destination, " +
              "each session uses a different source UDP port for " +
              "ECMP.";
            leaf source-addr {
              type inet:ip-address;
              description "BFD source address";
            }
            leaf dest-addr {
              type inet:ip-address;
              description "BFD peer address";
            }
            list session-ip-mh {
              key "source-port";
              description 
                "The BFD sessions between a source and a. " +
                "destination. Source UDP port is unique for " +
                "each session in the group.";
              leaf ttl {
                type ttl;
                description "TTL of outgoing packets";
              }
              uses bfd-all-session;
            }
          }
          list session-te-tunnel {
            key "tunnel-name";
            description "BFD over TE tunnel";
            leaf tunnel-name {
              type string;
              description "Name of TE tunnel";
            }
            uses bfd-all-session;
          }
          list session-ldp-lsp-group {
            key "ldp-fec";
            description
              "BFD over LDP LSP group of sessions. A group of " +
              "sessions is to one LDP FEC, each session uses a " +
              "different source UDP port for ECMP.";
            leaf ldp-fec {
              type inet:ip-prefix;
              description "LDP FEC";
            }
            list session-ldp-lsp {
              key "source-port";
              description 
                "The BFD sessions on an LDP FEC. Source UDP " +
                "port is unique for each session in the group.";
              leaf ttl {
                type ttl;
                description "TTL of outgoing packets";
              }
              uses bfd-all-session;
            }
          }
          list session-lag {
            key "lag-name";
            description "A LAG interface on which BFD is running";
            leaf lag-name {
              type if:interface-ref ;
              description "Name of the LAG";
            }
            list session-lag-micro {
            key "member-link";
              description 
                "Micro-BFD over LAG. This represents BFD " +
                "over one member link";
              leaf member-link {
                type if:interface-ref;
                description 
                  "Member link on which micro-BFD is running";
              }
              uses bfd-all-session;
            }
          }
        }
      }
    }
  }
  
  grouping bfd-notification-parms {
    description
      "This group describes common parameters that will be sent " +
      "as part of BFD notification";
        
    leaf local-discr {
      type discriminator;
      description "BFD local discriminator";
    }
        
    leaf remote-discr {
      type discriminator;
      description "BFD remote discriminator";
    }
        
    leaf new-state {
      type state;
      description "Current BFD state";
    }
        
    leaf state-change-reason {
      type string;
      description "BFD state change reason";
    }
        
    leaf time-in-previous-state {
      type string;
      description 
        "How long the BFD session was in the previous state";
    }
        
    leaf dest-addr {
      type inet:ip-address;
      description "BFD peer address";
    }
    leaf source-addr {
      type inet:ip-address;
      description "BFD local address";
    }
    leaf session-index {
      type uint32;
      description "An index used to uniquely identify BFD sessions";
    }
    leaf session-type {
      type bfd-session-type;
      description "BFD session type";
    }
  }
    
  notification bfd-singlehop-notification {
    description 
      "Notification for BFD single-hop session state change. An " +
      "implementation may rate-limit notifications, e.g. when a" +
      "session is continuously changing state.";
    uses bfd-notification-parms;
        
    leaf interface {
      type if:interface-ref;
      description "Interface to which this BFD session belongs to";
    }
        
    leaf echo-enabled {
      type boolean;
      description "Was echo enabled for BFD";
    }
  }
    
    
  notification bfd-multihop-notification {
    description 
      "Notification for BFD multi-hop session state change. An " +
      "implementation may rate-limit notifications, e.g. when a" +
      "session is continuously changing state.";
    uses bfd-notification-parms;        
  }
  notification bfd-te-tunnel-notification {
    description 
      "Notification for BFD over TE tunnel session state change. " +
      "An implementation may rate-limit notifications, e.g. when a" +
      "session is continuously changing state.";
    uses bfd-notification-parms;
        
    leaf tunnel-name {
      type string;
      description "TE tunnel to which this BFD session belongs to";
    }
  }
  notification bfd-ldp-lsp-notification {
    description 
      "Notification for BFD over LDP LSP session state change. " +
      "An implementation may rate-limit notifications, e.g. when a" +
      "session is continuously changing state.";
    uses bfd-notification-parms;
        
    leaf ldp-fec {
      type inet:ip-prefix;
      description "LDP FEC";
    }
    leaf source-port {
      type inet:port-number;
      description "Source UDP port";
    }
  }
  notification bfd-lag-notification {
    description 
      "Notification for BFD over LAG session state change. " +
      "An implementation may rate-limit notifications, e.g. when a" +
      "session is continuously changing state.";
    uses bfd-notification-parms;
        
    leaf lag-name {
      type if:interface-ref;
      description "LAG interface name";
    }
    leaf member-link {
      type if:interface-ref;
      description "Member link on which BFD is running";
    }
  }
}
<CODE ENDS>
        ]]></artwork>
                </figure>
            </section>
            <section title="BFD Client Example Configuration Yang Module">
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
module example-bfd-routing-app {
   namespace "urn:ietf:params:xml:ns:yang:example-bfd-routing-app";
   prefix bfd-routing-app;

   import ietf-bfd {
     prefix "bfd";
   }

   import ietf-interfaces {
     prefix "if";
   }

   organization
     "ACME";
   contact
     "acme@acme.com";

   description
     "Testing BFD grouping (simulating a routing application)";

   revision 2015-07-01 {
     description "Initial revision.";
     reference "RFC XXXX: An example BFD routing application";
   }

   feature routing-app-bfd {
     description "BFD configuration under routing-app";
   }

   list area {
     key "area-id";

     description "Specify a routing area.";

     leaf area-id {
       type uint32;
       description "Area";
     }

     uses bfd:bfd-client-base-cfg-parms {
       if-feature routing-app-bfd;
     }

     list interface {
       key "interface";
       description "List of interfaces";
       leaf interface {
         type if:interface-ref;
         description "Interface";
       }
       uses bfd:bfd-client-base-cfg-parms {
         if-feature routing-app-bfd;
       }
     }

   }
}

        </artwork>
                </figure>
            </section>
            <section title="Security Considerations">
                <t>The YANG module defined in this memo is designed to be accessed via the NETCONF protocol [RFC6241]. The lowest NETCONF layer is the secure transport layer and the mandatory to implement secure transport is SSH [RFC6242]. The NETCONF access control model [RFC6536] provides the means to restrict access for particular NETCONF users to a pre-configured subset of all available NETCONF protocol operations and content.</t>
                <t>The YANG module has writeable data nodes which can be used for creation of BFD sessions and modification of BFD session parameters. The system should "police" creation of BFD sessions to prevent new sessions from causing existing BFD sessions to fail. For BFD session modification, the BFD protocol has mechanisms in place which allow for in service modification. </t>
            </section>
            <section title="IANA Considerations">
                <t>The IANA is requested to as assign a new new namespace URI from the
      IETF XML registry.</t>
                <t>URI:TBD</t>
            </section>
            <section title="Acknowledgements">
                <t>We would also like to thank Nobo Akiya and Jeff Haas for their
      encouragement on this work.</t>
            </section>
        </section>
    </middle>
    <back>
        <references title="Normative References"><?rfc include="reference.RFC.2119"?><?rfc include='reference.RFC.6020'?><?rfc include='reference.RFC.6241'?><?rfc include='reference.RFC.5880'?><?rfc include='reference.RFC.5881'?><?rfc include='reference.RFC.5882'?><?rfc include='reference.RFC.5883'?><?rfc include='reference.RFC.5884'?><?rfc include='reference.RFC.7130'?>
        </references>
        <references title="Informative References">
           <?rfc include="reference.I-D.ietf-netconf-restconf"?>
           <?rfc include="reference.I-D.ietf-netmod-routing-cfg"?>
        </references>
        <section title="Change log">
           <t>RFC Editor: Remove this section upon publication as an RFC.</t>
           <section title="Changes between versions -03 and -04">
              <t>
              <list style="symbols">
                 <t>Follow VRF-centric model</t>
                 <t>IP single-hop session configuration in BFD clients</t>
              </list>
              </t>
           </section>
           <section title="Changes between versions -02 and -03">
              <t>
              <list style="symbols">
                 <t>Fixed date mismatch</t>
                 <t>Updated authors</t>
              </list>
              </t>
           </section>
           <section title="Changes between versions -01 and -02">
              <t>
              <list style="symbols">
                 <t>Fixed errors and warnings from "pyang --ietf"</t>
                 <t>Added appendix for "Change log"</t>
              </list>
              </t>
           </section>
           <section title="Changes between versions -00 and -01">
              <t>In the YANG module section:
                 <list style="symbols">
                    <t>Added missing filename</t>
                    <t>Added missing CODE ENDS</t>
                 </list>
              </t>
           </section>
        </section>
    </back>
</rfc>